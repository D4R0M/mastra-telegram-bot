Got it—here’s a tightened, single-user version you can paste into your AI code assistant:

---

# Build a Telegram Active-Recall Vocabulary Bot (Single User Only)

**Goal**
Create a Telegram bot that helps *me* learn vocabulary using active recall + spaced repetition (SM-2). It should quiz me and DM me when it’s time to review. **The bot must only respond to my chat ID** and ignore everyone else.

## Scope & Assumptions (Single User)

* Exactly one user: **me**.
* The bot should silently ignore any message not coming from `MY_CHAT_ID`.
* Default timezone: **Europe/Stockholm** (respect DST).
* Language: English UI (keep strings in one place for easy tweaks).

## Tech & Deliverables

* **Python 3.11**
* **Framework:** `python-telegram-bot` v21+ (or `aiogram` v3—pick one)
* **Scheduler:** Built-in PTB JobQueue *or* `APScheduler` (persist next runs)
* **DB:** SQLite (no multi-user schema; simple and robust)
* **Container:** Dockerfile + docker-compose
* **Config via `.env`:**

  * `TELEGRAM_BOT_TOKEN`
  * `MY_CHAT_ID` (int)
  * `TZ=Europe/Stockholm`
  * `DATABASE_URL=sqlite:///data.db`
* **Repo layout (lean):**

  ```
  app/
    bot.py
    config.py
    db.py
    models.py
    srs.py
    handlers.py
    scheduler.py
    keyboards.py
    utils.py
  tests/
  Dockerfile
  docker-compose.yml
  README.md
  ```

## Hard Single-User Rules

* On every update, check `update.effective_chat.id == MY_CHAT_ID`; otherwise return immediately.
* Disable `/start` for others with a generic “private bot” message (no details).

## Features

### 1) Add & Manage Cards

* `/add` guided flow:

  * front (L2 word) → back (L1 meaning/sentence) → optional tags/example/POS
* `/list` (paginate 20; filter by tag)
* `/edit <id>` and `/delete <id>`
* Quick add shortcut:
  `"/add hej :: hello :: greeting"`

### 2) Review (Active Recall)

* `/review` starts a session:

  * Show **front only**, button **Show Answer** → then grade buttons: **0 Forgot**, **3 Hard**, **4 Good**, **5 Easy**
  * Optional direction flip: `/review l1` (answer→word)
  * Default session cap: 10 cards (configurable via `/settings`)
* **SM-2 logic** (Anki-style):

  * Fields: repetitions, interval\_days, ease\_factor, due\_at, last\_grade
  * EF starts at 2.5; apply standard SM-2 EF update with floor 1.3
  * Lapses (`q<3`) reset reps and set short interval (1 day)
* (Optional) Leitner mode toggle in settings

### 3) Automatic Reminders

* One summary DM when cards come due:

  * “You have **X** cards due. Start review?” \[Start]
* Respect **Do Not Disturb** (e.g., 21:00–08:00)
* Configurable reminder time/window:

  * `/remind on|off`
  * `/remind set 10:00`
  * `/remind window 08:00-21:00`
* Jobs must persist across restarts (rehydrate from DB on boot)

### 4) Import/Export

* `/import` accept CSV/TSV (detect header; simple mapper)

  ```
  front,back,tags,example,lang_front,lang_back
  hej,hello,greeting,,sv,en
  ```
* `/export` send a CSV of all cards (optionally include scheduling fields)

### 5) Settings & Stats

* `/settings` inline menu:

  * Session size (default 10)
  * Daily new cards cap (default 10)
  * Daily review cap (default 100)
  * Reminder on/off, time/window, DND
  * Algorithm: SM-2 (default) / Leitner (optional)
  * Timezone (default Europe/Stockholm—stored but fixed for single user)
* `/stats` text summary:

  * Due today, done today, streak, retention %, ease histogram (text buckets)

## Minimal Data Model (SQLAlchemy, single user)

* `Card(id, front, back, tags, example, lang_front, lang_back, active, created_at, updated_at)`
* `ReviewState(card_id, repetitions, interval_days, ease_factor, due_at, last_grade, last_reviewed_at, direction_mode)`
* `ReviewLog(id, card_id, ts, grade, latency_ms, direction)`
* `Prefs(id=1, remind_enabled, remind_time, window_start, window_end, dnd_start, dnd_end, session_cap, algo, tz)`

## SM-2 Reference (implement verbatim)

* On grade `q` (0–5):

  * If `q < 3`:

    * `repetitions = 0`
    * `interval_days = 1` (or short lapse interval)
    * `due_at = now + 1 day`
  * Else:

    * `ease_factor = max(1.3, EF + (0.1 - (5 - q)*(0.08 + (5 - q)*0.02)))`
    * If `repetitions == 0`: `interval_days = 1`
    * Elif `repetitions == 1`: `interval_days = 6`
    * Else: `interval_days = round(interval_days * ease_factor)`
    * `repetitions += 1`
    * `due_at = now + interval_days`

## Jobs & Persistence

* On boot:

  * Load `Prefs`, schedule the daily reminder job inside the allowed window
  * Kick a periodic check (e.g., every 15 min) to DM if `due_at <= now` and within window + not in DND
* If 0 due cards at reminder time → send nothing

## Security & Safety (Single User)

* Hard-check `MY_CHAT_ID` on every update & job send
* Never echo secrets; log minimally
* Back up `data.db` (SQLite) and CSV exports

## Commands (single user)

* `/start` — short welcome + guard for others
* `/add`, `/list`, `/edit`, `/delete`
* `/review` (optional `/review l1`)
* `/remind`, `/settings`, `/stats`, `/import`, `/export`, `/help`

## Tests

* Unit tests for SM-2 transitions and due selection
* Parse tests for quick-add string
* Basic test for reminder window/DND gating

## Acceptance Criteria (Single User)

* Only my `MY_CHAT_ID` can use the bot; others are ignored with a generic message
* I can add, review, and get automatic reminders in **Europe/Stockholm**
* SM-2 scheduling works and persists across restarts
* Import/export works via CSV
* Settings and stats function as described

**Please generate the complete implementation (Python), with comments, Docker files, and a concise README focused on single-user operation.**
